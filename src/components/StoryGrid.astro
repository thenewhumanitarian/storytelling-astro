---
const { stories } = Astro.props
---

<div class={`stories-container`} id='stories-container'>
	<div id='grid' class='grid'></div>
</div>

<!-- Library to help moving around the grid -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/animejs/2.2.0/anime.min.js' is:inline></script>

<style is:global>
	header {
		/* Makes header fixed whenever a Storygrid is present */
		position: fixed;
		z-index: 9999 !important;
	}
	.stories-container span {
		position: fixed;
		z-index: 5000;
		top: 0;
		left: 0;
		width: 50px;
		height: 50px;
		background: white;
	}
	.stories-container {
		top: 0;
		left: 0;
		position: fixed;
		display: block;
		overflow: hidden;
		width: 100%;
		height: 100vh;
		z-index: 5555;
	}
	.grid {
		display: grid;
		width: 100%;
		height: 100%;
		overflow: hidden;
		gap: 0;
	}
	.grid-item {
		position: relative;
		background: black;
		background-size: cover;
		background-position: center center;
		user-select: none;
		overflow: hidden;
		will-change: all;
		transition: transform 0.25s ease-in-out;
		transform: scale(1);
	}
	.filter--read .grid-item:not([data-lastread='never']) {
		opacity: 0.2;
	}
	/* .grid-item a:hover {
		text-decoration: none;
		pointer-events: none;
	} */
	@media screen and (min-width: 800px) {
		.grid-item {
			outline: 10px solid transparent;
		}
		.grid-item:not(.filter--read):hover,
		.grid-item[data-lastread='never']:hover {
			transform: scale(1.05);
			outline: 0.7rem solid white;
			opacity: 1;
			z-index: 9999;
		}
		.filter--read .grid-item[data-lastread='never']:hover .grid-item--title {
			color: black;
			background: white;
		}
		.filter--read .grid-item:not([data-lastread='never']) {
			pointer-events: none;
		}
	}
	.grid-item--title {
		margin: 0;
		box-decoration-break: clone;
		font-size: 1.4rem;
		line-height: 1.15;
		padding: 0 0.4rem;
		/* pointer-events: auto; */
		cursor: pointer;
	}
	.grid-item--title:hover {
		cursor: pointer;
	}
	.grid-item--link {
		display: none;
	}
	.grid-item:hover .grid-item--link {
		display: block;
		position: absolute;
		background: white;
		color: black;
		padding: 0.25rem 0.5rem;
		bottom: 0;
		right: 0;
		z-index: 9999;
	}
	.grid-item--link:hover {
		cursor: pointer;
	}
	@media screen and (max-width: 500px) {
		.grid-item--title {
			font-size: 1rem;
			height: auto;
		}
	}
</style>

<script async define:vars={{ stories }} is:inline>
if (localStorage.getItem('showAll') === 'false') {
	document.getElementById('grid').classList.add('filter--read')
} else {
	document.getElementById('grid').classList.remove('filter--read')
}

// window.addEventListener('DOMContentLoaded', function () {
window.addEventListener('pageshow', function () {
	// Add class to #grid if localStorage('showAll') is set to false
	if (localStorage.getItem('showAll') === 'false') {
		document.getElementById('grid').classList.add('filter--read')
	} else {
		document.getElementById('grid').classList.remove('filter--read')
	}
	// Get the read articles from localStorage or use an empty array if it doesn't exist
	let readArticles = JSON.parse(localStorage.getItem('readArticles')) || []

	// Loop through all .grid-element items on the page
	let gridElements = document.querySelectorAll('.grid-element')
	gridElements.forEach((element) => {
		// Assuming each .grid-element has a data attribute (e.g., data-slug) that stores its slug
		let slug = element.getAttribute('data-slug')

		// Find the corresponding read article based on the slug
		let readArticle = readArticles.find((article) => article.slug === slug)

		if (readArticle) {
			// If the article has been read before, set the data-lastread attribute
			element.setAttribute('data-lastread', readArticle.timestamp)
			element.style.opacity = 0.2
		} else {
			// If the article hasn't been read, remove the data-lastread attribute (if it exists)
			element.setAttribute('data-lastread', 'never')
		}
	})

	const grid = optimalGridDimensions()
	Infinite.setGrid(grid.cols, grid.rows)
})

/* Cursor management */

let moveTimeout

const storiesContainer = document.querySelector('.stories-container')

storiesContainer.addEventListener('mousemove', function () {
	this.style.cursor = 'move'
})

storiesContainer.addEventListener('mousemove', function () {
	// Clear any existing timeout
	if (moveTimeout) {
		clearTimeout(moveTimeout)
	}

	// Set the cursor to 'grab' when the mouse is moving
	this.style.cursor = 'move'

	// After 1 second of no movement, set the cursor to 'pointer'
	// moveTimeout = setTimeout(() => {
	// 	this.style.cursor = 'pointer'
	// }, 250)
})

console.clear()

/* Grid magic */
class GridItem {
	constructor(index = 0) {
		this.item = document.createElement('a')
		// Create h2 element for title
		this.title = document.createElement('h2')
		this.item.append(this.title)
		this.index = index
		this.item.classList.add('grid-item')
		this.setNewCard()
	}

	setIndex(index) {
		this.index = index
		this.setNewCard()
	}

	setNewCard() {
		// Define vars to be used later
		let story = stories[this.index % stories.length]
		let title = stories[this.index % stories.length].title
		// this.item.setAttribute('transition:name', 'image')
		// Check if article was read before and write date of last read if that's the case
		let readArticles = JSON.parse(localStorage.getItem('readArticles')) || []
		let readArticle = readArticles.find((article) => article.slug === story.slug)
		if (readArticle) {
			// If the current article has been read before, set the data-lastread attribute with the timestamp
			this.item.setAttribute('data-lastread', readArticle.timestamp)
		} else {
			// If the current article has not been read, set data-lastread to a default value or omit this part altogether
			this.item.setAttribute('data-lastread', 'never')
		}
		// Set title classes and add text
		this.title.classList.add('grid-item--title')
		this.title.classList.add('box-decoration-clone')
		this.title.classList.add('px-2')
		this.title.classList.add('leading-7')
		this.title.classList.add('text-white')
		this.title.classList.add('bg-black')
		this.title.classList.add('inline')
		this.title.classList.add('pt-0')
		this.title.classList.add('sm:pt-8')
		this.title.classList.add('pointer-events-none')
		this.title.classList.add('sm:pointer-events-auto')
		this.title.innerHTML = title
		this.item.style.backgroundImage = `url('/downloaded_images/thumbnails/${story.image.fileName}')`
		this.item.style.backgroundSize = 'cover'
		this.item.style.backgroundPosition = 'center center'
		// Add href to this grid item using slug
		this.item.setAttribute('href', `/stories/${story.slug}`)
	}
}

class Drag {
	constructor(ele, handleDrag) {
		this.dragging = false
		this.lastX = null
		this.lastY = null
		this.handleDrag = handleDrag
		this.touchStartTime = 0

		ele.addEventListener('click', this.onClick.bind(this), false)

		// if ('ontouchend' in window && window.innerWidth <= 768) { // 768px can be adjusted based on your mobile breakpoint
		// 		ele.addEventListener('touchend', this.onTap.bind(this));
		// }

		ele.addEventListener('touchstart', this.onStart.bind(this), false)
		ele.addEventListener('touchmove', this.onMove.bind(this), false)
		ele.addEventListener('touchend', this.onEnd.bind(this), false)

		ele.addEventListener('mousedown', this.onStart.bind(this))
		ele.addEventListener('mousemove', this.onMove.bind(this))
		ele.addEventListener('mouseup', this.onEnd.bind(this))
		ele.addEventListener('mouseuot', this.onEnd.bind(this))
	}

	// onTap(ev) {
	// 	ev = ev.type == 'touchstart' ? ev.touches[0] : ev

	// 	if (this.dragging) {
	// 		console.log('is dragging')
	// 		ev.preventDefault()
	// 	}
	// }

	onClick(ev) {
		ev = ev.type == 'touchstart' ? ev.touches[0] : ev

		if (this.dragging) {
			ev.preventDefault()
		}
	}

	onStart(ev) {
		this.touchStartTime = Date.now()
		ev.preventDefault()

		ev = ev.type == 'touchstart' ? ev.touches[0] : ev

		this.dragging = true

		// this.dragging = true
		this.lastX = ev.clientX
		this.lastY = ev.clientY
	}

	onMove(ev) {
		if (!this.dragging) return

		// Calculate the duration of the tap
		const touchDuration = Date.now() - this.touchStartTime;
		console.log(touchDuration)

		ev = ev.type == 'touchmove' ? ev.touches[0] : ev
		let xDelta = ev.clientX - this.lastX
		let yDelta = ev.clientY - this.lastY
		let vel = Math.abs(xDelta * yDelta)
		if (vel > 50) {
			// let v = { x: xDelta * 0.5, y: yDelta * 0.5 } // Make it more snappy
			let v = { x: xDelta * 0, y: yDelta * 0 }
			if (this.anime) this.anime.pause()
			this.anime = anime({
				targets: v,
				x: 0,
				y: 0,
				update: () => {
					this.handleDrag(v.x, v.y)
				},
			})
		}
		this.handleDrag(xDelta, yDelta)
		this.lastX = ev.clientX
		this.lastY = ev.clientY
	}

	onEnd(ev) {
		this.dragging = false

		// Calculate the duration of the tap
		const touchDuration = Date.now() - this.touchStartTime;
		console.log(touchDuration)

		// Check duration and act accordingly
		if (touchDuration < 100) { // This checks if the touch lasted less than 500ms
			// This was a short tap
			if (event.target.tagName.toLowerCase() === 'a') {
				const href = event.target.getAttribute('href');
				if (href) {
						window.location = href;
				}
			}
		} 
	}
}
class InfiniteGrid {
	constructor(nCol = 2, nRow = 2) {
		this.grid = document.getElementById('grid')
		this.container = document.getElementById('stories-container')
		this.Drag = new Drag(this.container, this.onDrag.bind(this))
		this.offsetX = 0
		this.offsetY = 0
		// Overshoot items
		this.items = []
		this.setGrid(nCol, nRow)
	}

	onDrag(xDelta, yDelta) {
		this.offsetX += xDelta
		this.offsetY += yDelta

		// Move the grid back by 1 item whenever it goes over 1/2 of an item
		// Making the movement invisible
		const itemWidth = 100 / this.cols
		const itemHeight = 100 / this.rows
		const pixelWidth = (itemWidth * window.innerWidth) / 100
		const pixelHeight = (itemHeight * window.innerHeight) / 100
		let jumpX = null
		let jumpY = null

		if (Math.abs(this.offsetX) > pixelWidth / 2) {
			this.offsetX -= pixelWidth * Math.sign(this.offsetX)
			jumpX = Math.sign(this.offsetX)
		}

		if (Math.abs(this.offsetY) > pixelHeight / 2) {
			this.offsetY -= pixelHeight * Math.sign(this.offsetY)
			jumpY = Math.sign(this.offsetY)
		}

		// console.log(this.rows, this.cols, jumpY)

		if (jumpX || jumpY) {
			this.items.forEach((item) => {
				if (jumpX) item.setIndex(this.shiftIndex(item.index + jumpX))
				if (jumpY) item.setIndex(this.shiftIndex(item.index + jumpY * (this.cols + 2)))
			})
		}

		this.grid.style.transform = `translate(${this.offsetX}px,${this.offsetY}px)`
	}

	shiftIndex(index) {
		if (index < 0) {
			index = this.items.length + index
		}

		index = index % this.items.length

		return index
	}

	setGrid(nCol = 2, nRow = 2) {
		if (nCol === this.cols && nRow === this.rows) return

		// Overshoot items
		const cols = nCol + 2
		const rows = nRow + 2
		// Add space for 2 more rows and columns using the current col/row size
		this.container.style.width = `${100 + (100 / nCol) * 2}vw`
		this.container.style.height = `${100 + (100 / nRow) * 2}vh`
		// Move the grid back by 1 col and row
		this.container.style.transform = `translate(${-100 / nCol}vw, ${-100 / nRow}vh)`

		// Do everything else taking into account the overshoot items
		this.grid.style.gridTemplateColumns = Array.from({ length: cols }, () => '1fr').join(' ')
		this.grid.style.gridTemplateRows = Array.from({ length: rows }, () => '1fr').join(' ')

		const nItems = cols * rows
		this.cols = nCol
		this.rows = nRow

		while (nItems < this.items.length) {
			this.grid.removeChild(this.grid.children[this.items.length - 1])
			this.items = this.items.slice(0, this.items.length - 1)
		}

		while (nItems > this.items.length) {
			const item = new GridItem(this.items.length)
			this.items = this.items.concat(item)
			this.grid.append(item.item)
		}

		this.items.forEach((item, index) => {
			item.setIndex(index)
		})
	}
}

const grid = optimalGridDimensions()
const Infinite = new InfiniteGrid(grid.cols, grid.rows)

window.addEventListener('resize', () => {
	const grid = optimalGridDimensions()
	Infinite.setGrid(grid.cols, grid.rows)
})

function optimalGridDimensions(minSide = window.innerWidth > 500 ? 200 : 130) {
	const width = window.innerWidth
	const height = window.innerHeight

	const maxCols = Math.floor(width / minSide)
	const maxRows = Math.floor(height / minSide)

	let bestCols = 1
	let bestRows = maxRows
	let closestToSquare = Infinity

	for (let cols = 1; cols <= maxCols; cols++) {
		const cellWidth = width / cols
		const rowsForSquare = Math.floor(height / cellWidth)

		if (rowsForSquare > 0 && cellWidth >= minSide) {
			const aspectRatioDiff = Math.abs(cellWidth * cols - (width * rowsForSquare) / height)

			if (aspectRatioDiff < closestToSquare) {
				closestToSquare = aspectRatioDiff
				bestCols = cols
				bestRows = rowsForSquare
			}
		}
	}

	return {
		cols: bestCols,
		rows: bestRows,
	}
}
</script>
